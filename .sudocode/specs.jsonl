{"id":"s-6t4r","uuid":"c8d7bbdf-80cb-4f8c-8d74-6fce1085f8ba","title":"ACP Factory Library","file_path":"specs/s-6t4r_acp_factory_library.md","content":"# ACP Factory Library\n\nA TypeScript library for spawning and managing agents through the Agent Client Protocol (ACP).\n\n## Goal\n\nCreate a clean, minimal library that allows applications to:\n- Spawn coding agents (starting with Claude Code, eventually supporting Codex, Gemini, etc.)\n- Interact with agents through the standardized ACP protocol\n- Handle streaming responses, permissions, and file operations\n\n## Requirements\n\n### Functional Requirements\n\n1. **Agent Spawning**\n   - Spawn agent subprocesses (e.g., `claude-code-acp`)\n   - Establish ACP connection over stdin/stdout using NDJSON\n   - Initialize connection and negotiate capabilities\n\n2. **Session Management**\n   - Create new sessions with a working directory\n   - Load existing sessions by ID\n   - Support multiple concurrent sessions per agent\n\n3. **Prompt/Response Flow**\n   - Send prompts (text, images, resources)\n   - Receive streaming session updates via async iterators\n   - Handle all update types: `agent_message_chunk`, `tool_call`, `tool_call_update`, `plan`, etc.\n\n4. **Permission Handling**\n   - Configurable permission callback\n   - Default to auto-approve (suitable for dev/trusted environments)\n   - Support auto-deny and require-callback modes\n\n5. **File Operations**\n   - Default to filesystem reads/writes\n   - Allow custom handlers for sandboxing\n\n6. **Provider Registry**\n   - Register agent configurations by name\n   - Pre-register Claude Code provider\n   - Extensible for future agents (Codex, Gemini)\n\n### Non-Functional Requirements\n\n- Minimal dependencies (only `@agentclientprotocol/sdk`)\n- Clean TypeScript types\n- Async-first design with proper cleanup\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────┐\n│  Application                                        │\n│                                                     │\n│  const agent = await AgentFactory.spawn(\"claude\");  │\n│  const session = await agent.createSession(cwd);    │\n│  for await (const update of session.prompt(msg)) {} │\n└───────────────────────┬─────────────────────────────┘\n                        │\n┌───────────────────────▼─────────────────────────────┐\n│  acp-factory library                                │\n│                                                     │\n│  AgentFactory → AgentHandle → Session               │\n│                                                     │\n│  ACPClientHandler (implements acp.Client)           │\n│  - requestPermission() → callback/auto              │\n│  - sessionUpdate() → async iterator                 │\n│  - readTextFile/writeTextFile → fs/callback         │\n└───────────────────────┬─────────────────────────────┘\n                        │ stdin/stdout (NDJSON)\n┌───────────────────────▼─────────────────────────────┐\n│  Agent Subprocess (claude-code-acp, etc.)           │\n└─────────────────────────────────────────────────────┘\n```\n\n## Core API Design\n\n### AgentFactory\n```typescript\ninterface AgentConfig {\n  command: string;      // e.g., \"npx\"\n  args: string[];       // e.g., [\"claude-code-acp\"]\n  env?: Record<string, string>;\n}\n\nclass AgentFactory {\n  static register(name: string, config: AgentConfig): void;\n  static spawn(name: string, options?: SpawnOptions): Promise<AgentHandle>;\n}\n```\n\n### AgentHandle\n```typescript\nclass AgentHandle {\n  readonly capabilities: AgentCapabilities;\n  createSession(cwd: string, options?: SessionOptions): Promise<Session>;\n  loadSession(sessionId: string): Promise<Session>;\n  close(): Promise<void>;\n}\n```\n\n### Session\n```typescript\nclass Session {\n  readonly id: string;\n  readonly modes: string[];\n  readonly models: string[];\n  \n  prompt(content: PromptContent): AsyncIterable<SessionUpdate>;\n  cancel(): Promise<void>;\n  setMode(mode: string): Promise<void>;\n}\n```\n\n## Design Decisions\n\n1. **Async iterators for streaming** - `prompt()` returns `AsyncIterable<SessionUpdate>` for natural `for await...of` consumption\n\n2. **Configurable permissions with auto-approve default** - Suitable for development; can require explicit handler or auto-deny\n\n3. **Default file ops to fs** - Simple default; overridable for sandboxing\n\n4. **Pre-registered providers** - Claude Code registered by default; users can register others\n\n5. **Package name**: `acp-factory`\n\n## File Structure\n\n```\nsrc/\n├── index.ts              # Public exports\n├── types.ts              # Type definitions\n├── factory.ts            # AgentFactory\n├── agent-handle.ts       # AgentHandle\n├── session.ts            # Session\n├── client-handler.ts     # ACPClientHandler\n└── providers/\n    └── claude-code.ts    # Claude Code config\n```\n\n## Reference Implementations\n\n- ACP TypeScript SDK: `references/typescript-sdk/`\n- Claude Code ACP Adapter: `references/claude-code-acp/`\n","priority":1,"archived":0,"archived_at":null,"created_at":"2025-12-11 19:30:58","updated_at":"2025-12-11 19:30:58","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["acp","agents","library","typescript"]}
{"id":"s-5crl","uuid":"30e92cd7-42fe-46aa-abfe-cfc18f42685e","title":"Sandbox Support for claude-code-acp-fork","file_path":"specs/s-5crl_sandbox_support_for_claude_code_acp_fork.md","content":"# Sandbox Support for claude-code-acp-fork\n\n## Overview\n\nAdd OS-level sandboxing to the forked `claude-code-acp` agent using Anthropic's `@anthropic-ai/sandbox-runtime` package. This enables the agent to self-sandbox, restricting filesystem and network access for all operations it performs.\n\n## Goals\n\n1. **Security**: Prevent the agent from accessing unauthorized files or network domains\n2. **Reduced friction**: Auto-allow bash commands when sandboxed (fewer permission prompts)\n3. **Configurability**: Allow clients to specify sandbox settings per-session via ACP protocol\n4. **Visibility**: Surface sandbox violations to clients for transparency\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│  Client (acp-factory)                                       │\n│  - Passes sandbox config via initialize() _meta             │\n└─────────────────────┬───────────────────────────────────────┘\n                      │ ACP JSON-RPC\n                      ▼\n┌─────────────────────────────────────────────────────────────┐\n│  claude-code-acp-fork                                       │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │ SandboxManager.initialize(config)                     │  │\n│  │   ├── Filesystem: denyRead, allowWrite, denyWrite     │  │\n│  │   └── Network: allowedDomains, deniedDomains          │  │\n│  └───────────────────────────────────────────────────────┘  │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │ All operations now sandboxed:                         │  │\n│  │   - Bash tool → restricted shell execution            │  │\n│  │   - File operations → path restrictions enforced      │  │\n│  │   - Network → proxy-based domain filtering            │  │\n│  └───────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Configuration Schema\n\n### SandboxConfig (passed via ACP `_meta`)\n\n```typescript\ninterface SandboxConfig {\n  /** Enable sandbox enforcement */\n  enabled: boolean;\n  \n  /** Auto-allow Bash commands when sandboxed (reduces prompts) */\n  autoAllowBashIfSandboxed?: boolean;\n  \n  /** Network restrictions */\n  network?: {\n    /** Domains the agent can access (supports wildcards like *.github.com) */\n    allowedDomains?: string[];\n    /** Domains to explicitly block (overrides allowedDomains) */\n    deniedDomains?: string[];\n  };\n  \n  /** Filesystem restrictions */\n  filesystem?: {\n    /** Paths to deny read access (glob patterns) */\n    denyRead?: string[];\n    /** Paths to allow write access (default: cwd only) */\n    allowWrite?: string[];\n    /** Paths to explicitly deny write access */\n    denyWrite?: string[];\n  };\n}\n```\n\n### Example Configuration\n\n```typescript\n{\n  enabled: true,\n  autoAllowBashIfSandboxed: true,\n  network: {\n    allowedDomains: [\n      'npmjs.org',\n      '*.npmjs.org',\n      'github.com',\n      '*.githubusercontent.com',\n      'registry.yarnpkg.com',\n    ],\n    deniedDomains: [],\n  },\n  filesystem: {\n    denyRead: [\n      '~/.ssh/**',\n      '~/.aws/**',\n      '~/.config/gh/**',\n      '.env',\n      '.env.*',\n      '**/*.pem',\n      '**/credentials*',\n    ],\n    allowWrite: ['.', '/tmp'],\n    denyWrite: ['.env', '.env.*', '**/*.pem'],\n  },\n}\n```\n\n## Implementation Plan\n\n### Phase 1: Core Sandbox Integration\n\n#### 1.1 Add dependency\n- Add `@anthropic-ai/sandbox-runtime` to package.json dependencies\n\n#### 1.2 Create `src/sandbox.ts`\n- Define `SandboxConfig` TypeScript interface\n- Create `toSandboxRuntimeConfig()` converter function\n- Export utility functions for sandbox state management\n\n#### 1.3 Modify `src/acp-agent.ts`\n- Add sandbox state to `ClaudeAcpAgent` class:\n  - `private sandboxConfig?: SandboxConfig`\n  - `private sandboxInitialized: boolean = false`\n- Extract sandbox config from `initialize()` params `_meta.sandbox`\n- Call `SandboxManager.initialize()` when enabled\n- Add `isSandboxed()` method for querying state\n- Add cleanup in agent shutdown\n\n### Phase 2: Permission Integration\n\n#### 2.1 Modify `src/settings.ts`\n- Add `shouldAutoAllowWhenSandboxed()` function\n- Check `autoAllowBashIfSandboxed` flag for Bash tool calls\n\n#### 2.2 Update permission flow in `src/acp-agent.ts`\n- Integrate auto-allow logic into `canUseTool()` callback\n- When sandboxed + `autoAllowBashIfSandboxed`: return `true` for Bash\n\n### Phase 3: Violation Reporting\n\n#### 3.1 Subscribe to violations\n- Use `SandboxViolationStore.onViolation()` callback\n- Log violations via agent's logger\n\n#### 3.2 Surface to client (optional enhancement)\n- Emit sandbox violations as session updates\n- Define new `sessionUpdate` type: `sandbox_violation`\n\n### Phase 4: Testing\n\n#### 4.1 Unit tests (`src/tests/sandbox.test.ts`)\n- Test config conversion functions\n- Test auto-allow logic\n\n#### 4.2 Integration tests\n- Test sandbox initialization\n- Test that violations are detected (mock or real)\n\n## Files to Create/Modify\n\n| File | Action | Description |\n|------|--------|-------------|\n| `package.json` | Modify | Add `@anthropic-ai/sandbox-runtime` dependency |\n| `src/sandbox.ts` | Create | Sandbox types and utilities |\n| `src/acp-agent.ts` | Modify | Initialize sandbox, manage state |\n| `src/settings.ts` | Modify | Auto-allow logic for sandboxed bash |\n| `src/tests/sandbox.test.ts` | Create | Unit tests for sandbox module |\n\n## Platform Requirements\n\n- **macOS**: Uses Seatbelt (built-in, no extra install)\n- **Linux**: Requires `bubblewrap` package (`apt install bubblewrap`)\n- **Windows**: Not supported (sandbox-runtime limitation)\n\n## Security Considerations\n\n1. **Deny-first for writes**: Only explicitly allowed paths can be written\n2. **Allow-first for reads**: All reads allowed unless explicitly denied\n3. **Network proxy**: All traffic routed through local proxy for filtering\n4. **No escape hatch by default**: Unlike Claude Code CLI, no `dangerouslyDisableSandbox`\n\n## Open Questions\n\n1. Should we expose `excludedCommands` (commands that bypass sandbox)?\n2. Should violation reporting be opt-in or always-on?\n3. Should we support per-tool sandbox config (e.g., different network rules for WebFetch)?\n\n## Success Criteria\n\n- [ ] Agent can be initialized with sandbox config via ACP\n- [ ] Bash commands are sandboxed (filesystem + network restrictions apply)\n- [ ] Auto-allow reduces permission prompts when sandboxed\n- [ ] Violations are logged and optionally surfaced to client\n- [ ] Tests pass on macOS and Linux","priority":1,"archived":1,"archived_at":"2025-12-16T23:30:09.004Z","created_at":"2025-12-12 19:04:06","updated_at":"2025-12-16 23:30:09","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["claude-code-acp","feature","sandbox","security"]}
{"id":"s-948y","uuid":"d60c54e6-ced3-4719-a497-e820bb0567c9","title":"Session Forking Support for claude-code-acp-fork","file_path":"specs/s-948y_session_forking_support_for_claude_code_acp_fork.md","content":"# Session Forking Support for claude-code-acp-fork\n\n## Overview\n\nImplement the ACP `session/fork` method in claude-code-acp to allow clients to create new independent sessions from existing ones. This enables branching conversations, creating checkpoints, and generating summaries without affecting the original session history.\n\n## Background\n\n### ACP Protocol Support\n\nThe ACP protocol defines `session/fork` as an experimental method:\n\n```typescript\ntype ForkSessionRequest = {\n  sessionId: SessionId;  // Session to fork from\n  cwd: string;           // Working directory for new session\n  mcpServers?: McpServer[];\n  _meta?: Record<string, unknown>;\n};\n\ntype ForkSessionResponse = {\n  sessionId: SessionId;  // New forked session ID\n  modes?: SessionModeState;\n  models?: SessionModelState;\n  configOptions?: SessionConfigOption[];\n};\n```\n\n### Claude Agent SDK Support\n\nThe SDK supports forking via combination of options:\n\n```typescript\nconst options: Options = {\n  resume: existingSessionId,  // Session to fork from\n  forkSession: true,          // Create new ID instead of continuing\n  resumeSessionAt?: string,   // Optional: fork from specific message\n};\n```\n\n## Use Cases\n\n1. **Branching conversations** - Try different approaches without losing original context\n2. **Checkpointing** - Save state before risky operations\n3. **Summaries** - Generate summaries in isolated sessions\n4. **Parallel exploration** - Explore multiple solutions simultaneously\n\n## Implementation\n\n### 1. Advertise Capability\n\nModify the `initialize()` response to include fork capability:\n\n```typescript\n// In acp-agent.ts initialize() method\nreturn {\n  protocolVersion: 1,\n  agentCapabilities: {\n    sessionCapabilities: {\n      fork: {},  // Empty object signals support\n    },\n    promptCapabilities: {\n      image: true,\n      embeddedContext: true,\n    },\n    mcpCapabilities: {\n      http: true,\n      sse: true,\n    },\n  },\n  // ... rest of response\n};\n```\n\n### 2. Implement unstable_forkSession Method\n\nAdd to `ClaudeAcpAgent` class:\n\n```typescript\nasync unstable_forkSession(\n  params: ForkSessionRequest\n): Promise<ForkSessionResponse> {\n  const { sessionId, cwd, mcpServers, _meta } = params;\n\n  // Verify source session exists\n  if (!this.sessions[sessionId]) {\n    throw RequestError.invalidParams(`Session ${sessionId} not found`);\n  }\n\n  // Create new session with fork options\n  const newSessionResponse = await this.newSession({\n    cwd,\n    mcpServers,\n    _meta: {\n      ...(_meta || {}),\n      claudeCode: {\n        options: {\n          resume: sessionId,\n          forkSession: true,\n          // Optionally support forking from specific message\n          ...(_meta?.claudeCode?.options || {}),\n        },\n      },\n    },\n  });\n\n  return {\n    sessionId: newSessionResponse.sessionId,\n    modes: newSessionResponse.modes,\n    models: newSessionResponse.models,\n    configOptions: newSessionResponse.configOptions,\n  };\n}\n```\n\n### 3. Import Required Types\n\n```typescript\nimport {\n  ForkSessionRequest,\n  ForkSessionResponse,\n  // ... existing imports\n} from \"@agentclientprotocol/sdk\";\n```\n\n## Extended Features (Optional)\n\n### Fork from Specific Message\n\nSupport `resumeSessionAt` to fork from a specific point in conversation:\n\n```typescript\n// In _meta\n{\n  claudeCode: {\n    options: {\n      resumeSessionAt: \"message-uuid-here\"\n    }\n  }\n}\n```\n\n### Fork with Modified Context\n\nAllow clients to modify system prompt or settings in forked session:\n\n```typescript\n// In _meta\n{\n  systemPrompt: { append: \"Focus on summarizing.\" },\n  claudeCode: {\n    options: {\n      // fork options\n    }\n  }\n}\n```\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| `src/acp-agent.ts` | Add `unstable_forkSession` method, update capabilities |\n\n## Testing\n\n### Unit Tests\n\n```typescript\ndescribe(\"unstable_forkSession\", () => {\n  it(\"creates new session from existing one\", async () => {\n    // Create original session\n    const original = await agent.newSession({ cwd: \"/tmp\" });\n    \n    // Fork it\n    const forked = await agent.unstable_forkSession({\n      sessionId: original.sessionId,\n      cwd: \"/tmp\",\n    });\n    \n    // Verify different session IDs\n    expect(forked.sessionId).not.toBe(original.sessionId);\n  });\n\n  it(\"throws error for non-existent session\", async () => {\n    await expect(\n      agent.unstable_forkSession({\n        sessionId: \"non-existent\",\n        cwd: \"/tmp\",\n      })\n    ).rejects.toThrow();\n  });\n\n  it(\"preserves conversation context in forked session\", async () => {\n    // Create and interact with original session\n    const original = await agent.newSession({ cwd: \"/tmp\" });\n    await agent.prompt({ sessionId: original.sessionId, prompt: \"Remember X=42\" });\n    \n    // Fork and verify context preserved\n    const forked = await agent.unstable_forkSession({\n      sessionId: original.sessionId,\n      cwd: \"/tmp\",\n    });\n    \n    // Query forked session about X\n    const response = await agent.prompt({ \n      sessionId: forked.sessionId, \n      prompt: \"What is X?\" \n    });\n    // Response should reference X=42\n  });\n});\n```\n\n## Success Criteria\n\n- [ ] Agent advertises `sessionCapabilities.fork` capability\n- [ ] `unstable_forkSession` method implemented\n- [ ] Forked sessions have independent session IDs\n- [ ] Forked sessions preserve conversation context from source\n- [ ] Modifications to forked session don't affect original\n- [ ] Error handling for non-existent source sessions\n- [ ] Unit tests pass","priority":1,"archived":0,"archived_at":null,"created_at":"2025-12-16 23:31:55","updated_at":"2025-12-16 23:31:55","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["claude-code-acp","feature","forking","session"]}
{"id":"s-2cxn","uuid":"c171895f-2c87-4695-b6b0-a6634851f800","title":"Session Fork-with-Flush for Running Sessions","file_path":"specs/s-2cxn_session_fork_with_flush_for_running_sessions.md","content":"# Session Fork-with-Flush for Running Sessions\n\n## Problem Statement\n\nCurrently, forking a session in `claude-code-acp` only works when the session data has been persisted to disk. However, Claude Code only persists sessions to disk when the CLI subprocess exits. This means:\n\n- **Forking a running session fails** - The forked session has no conversation context because the original session's data is still in memory\n- **Users cannot explore different directions** mid-conversation without losing context\n- **No checkpoint/save functionality** exists for running sessions\n\n## Solution Overview\n\nImplement a **fork-with-flush** mechanism that:\n\n1. Detects when the session being forked is currently active (in-progress)\n2. Gracefully pauses the session at a safe point (between messages/tool calls)\n3. Triggers disk persistence by aborting the subprocess\n4. Waits for the session file to appear on disk\n5. Restarts the original session (so it continues working)\n6. Creates the forked session (which now has full context)\n\nAdditionally, expose a **flush-only API** for creating checkpoints without forking.\n\n## Architecture\n\n### Current Flow (Broken for Active Sessions)\n\n```\nsession.fork()\n    ↓\ncreateSession({ resume: sessionId, forkSession: true })\n    ↓\nClaude CLI: --resume sessionId --fork-session\n    ↓\nCLI looks for ~/.claude/projects/<hash>/<sessionId>.jsonl\n    ↓\nFILE NOT FOUND (still in memory) → Fork has no context\n```\n\n### New Flow (Fork-with-Flush)\n\n```\nsession.fork()\n    ↓\nCheck if session is active\n    ↓ (if active)\nWait for idle OR timeout (~5s)\n    ↓\nInterrupt if still busy\n    ↓\nAbort session (triggers subprocess exit → disk write)\n    ↓\nWait for session file to exist with content\n    ↓\nRestart original session (new Query with resume)\n    ↓\nCreate forked session (new Query with resume + forkSession)\n    ↓\nBoth sessions have full conversation context!\n```\n\n## Requirements\n\n### R1: Detect Active Session State\n\nThe system must track whether a session is currently processing a prompt or is idle.\n\n**Implementation:**\n- Add `isProcessingPrompt: boolean` to Session type\n- Set to `true` when `prompt()` is called\n- Set to `false` when prompt completes or is cancelled\n\n### R2: Wait for Idle with Timeout\n\nWhen forking an active session, wait for it to become idle before flushing.\n\n**Behavior:**\n- Poll session state every 100ms\n- Break out as soon as session becomes idle\n- Respect configurable timeout (default: 5000ms)\n- If timeout exceeded while still processing, proceed to interrupt\n\n**Safe breakpoints:**\n- Between user messages\n- Between tool calls\n- After tool results\n\n### R3: Graceful Interrupt\n\nIf session doesn't become idle within timeout, interrupt it gracefully.\n\n**Implementation:**\n- Call `query.interrupt()` to stop current work\n- Wait brief period (100ms) for interrupt to propagate\n- Then proceed with abort\n\n### R4: Controlled Session Abort\n\nAbort the session to trigger subprocess exit and disk persistence.\n\n**Implementation:**\n- Store `AbortController` for each session\n- Call `abortController.abort()` to terminate\n- Subprocess exit triggers Claude Code's persistence logic\n\n### R5: Wait for Disk Persistence\n\nAfter abort, wait for session file to appear on disk.\n\n**Implementation:**\n- Compute session file path: `~/.claude/projects/<cwd-hash>/<sessionId>.jsonl`\n- Poll for file existence every 100ms\n- Verify file has content (size > 0)\n- Timeout after configurable period (default: 5000ms)\n- Throw error if persistence times out\n\n### R6: Restart Original Session\n\nAfter flush, restart the original session so it continues working.\n\n**Implementation:**\n- Create new `AbortController` for restarted session\n- Create new `Pushable<SDKUserMessage>` input stream\n- Create new `Query` with `resume: sessionId` (same session ID)\n- Preserve all session settings (mcpServers, permissionMode, etc.)\n- Update session entry in `this.sessions`\n\n### R7: Create Forked Session\n\nAfter flush and restart, create the forked session.\n\n**Implementation:**\n- Use existing `createSession()` with `{ resume: sessionId, forkSession: true }`\n- Fork now works because session file exists on disk\n- Return the new forked session\n\n### R8: Flush-Only API\n\nExpose ability to flush a session without forking (for checkpoints).\n\n**API:**\n```typescript\n// On ClaudeAcpAgent\nasync flushSession(sessionId: string): Promise<void>\n\n// Exposed via ACP extension method\nextMethod(\"_session/flush\", { sessionId })\n```\n\n**Behavior:**\n- Same as fork-with-flush steps 1-6\n- Does not create forked session\n- Returns after original session is restarted\n\n### R9: Smart Fork Detection\n\nAutomatically choose between immediate fork and fork-with-flush.\n\n**Logic:**\n```typescript\nasync unstable_forkSession(params) {\n  const session = this.sessions[params.sessionId];\n  \n  if (session && session.isActive) {\n    // Session is running in this process - use fork-with-flush\n    return this.forkWithFlush(params);\n  } else {\n    // Session not active (or from previous process) - try direct fork\n    return this.forkDirect(params);\n  }\n}\n```\n\n## Data Structures\n\n### Extended Session Type\n\n```typescript\ntype Session = {\n  query: Query;\n  input: Pushable<SDKUserMessage>;\n  cancelled: boolean;\n  permissionMode: PermissionMode;\n  settingsManager: SettingsManager;\n  \n  // NEW fields for fork-with-flush\n  abortController: AbortController;\n  isProcessingPrompt: boolean;\n  cwd: string;\n  mcpServers: Record<string, McpServerConfig>;\n  userProvidedOptions?: Options;\n};\n```\n\n### Fork Options\n\n```typescript\ntype ForkOptions = {\n  flushTimeout?: number;      // Max time to wait for idle (default: 5000ms)\n  persistenceTimeout?: number; // Max time to wait for disk write (default: 5000ms)\n  forceInterrupt?: boolean;   // Skip waiting, interrupt immediately\n};\n```\n\n## API Changes\n\n### New Methods on ClaudeAcpAgent\n\n```typescript\n/**\n * Flush a session to disk without forking.\n * Useful for creating checkpoints.\n */\nasync flushSession(sessionId: string, options?: FlushOptions): Promise<void>;\n\n/**\n * Fork with flush - handles active sessions.\n * @internal Called by unstable_forkSession when session is active\n */\nprivate async forkWithFlush(params: ForkSessionRequest): Promise<ForkSessionResponse>;\n\n/**\n * Direct fork - for sessions already persisted.\n * @internal Called by unstable_forkSession when session is inactive\n */\nprivate async forkDirect(params: ForkSessionRequest): Promise<ForkSessionResponse>;\n\n/**\n * Wait for session to become idle or timeout.\n * @internal\n */\nprivate async waitForIdle(sessionId: string, timeout: number): Promise<boolean>;\n\n/**\n * Wait for session file to exist on disk.\n * @internal\n */\nprivate async waitForPersistence(filePath: string, timeout: number): Promise<void>;\n\n/**\n * Restart a session after flush.\n * @internal\n */\nprivate async restartSession(sessionId: string, oldSession: Session): Promise<Session>;\n\n/**\n * Compute session file path from sessionId and cwd.\n * @internal\n */\nprivate getSessionFilePath(sessionId: string, cwd: string): string;\n```\n\n### Extension Method\n\n```typescript\n// Exposed via extMethod for clients\ncase \"_session/flush\":\n  await this.flushSession(params.sessionId as string, params.options);\n  return {};\n```\n\n## Session File Path Calculation\n\nClaude Code stores sessions at:\n```\n~/.claude/projects/<cwd-hash>/<sessionId>.jsonl\n```\n\nWhere `<cwd-hash>` is the cwd with `/` replaced by `-`:\n- `/private/tmp` → `-private-tmp`\n- `/Users/alex/project` → `-Users-alex-project`\n\n```typescript\nprivate getSessionFilePath(sessionId: string, cwd: string): string {\n  const cwdHash = cwd.replace(/\\//g, '-').replace(/^-/, '');\n  return path.join(CLAUDE_CONFIG_DIR, 'projects', cwdHash, `${sessionId}.jsonl`);\n}\n```\n\n## Error Handling\n\n| Scenario | Behavior |\n|----------|----------|\n| Session not found | Throw \"Session not found\" |\n| Flush timeout | Throw \"Session did not become idle within {timeout}ms\" |\n| Persistence timeout | Throw \"Session file not persisted within {timeout}ms\" |\n| Restart fails | Throw with original error, session left in flushed state |\n| Fork fails after flush | Original session continues, fork error propagated |\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Session state tracking**\n   - `isProcessingPrompt` set correctly during prompt\n   - State resets after prompt completes/cancels\n\n2. **Wait for idle**\n   - Returns true when session becomes idle\n   - Returns false and doesn't throw on timeout\n   - Respects timeout parameter\n\n3. **Session file path calculation**\n   - Various cwd formats handled correctly\n\n4. **Fork detection**\n   - Active sessions use fork-with-flush\n   - Inactive sessions use direct fork\n\n### E2E Tests\n\n1. **Fork active session**\n   - Create session, send prompt\n   - Fork while prompt is processing\n   - Verify both sessions have context\n\n2. **Fork idle session**\n   - Create session, send prompt, wait for completion\n   - Fork the idle session\n   - Verify fork has context\n\n3. **Flush checkpoint**\n   - Create session, send multiple prompts\n   - Call flush\n   - Verify session file exists\n   - Verify original session continues working\n\n4. **Timeout handling**\n   - Create session with long-running prompt\n   - Fork with short timeout\n   - Verify interrupt happens and fork succeeds\n\n## Sequence Diagram\n\n```\nClient              AcpAgent              Query/Subprocess         Disk\n  |                    |                        |                    |\n  |--fork(sessionId)-->|                        |                    |\n  |                    |--check isActive------->|                    |\n  |                    |<--true (processing)----|                    |\n  |                    |                        |                    |\n  |                    |--wait for idle-------->|                    |\n  |                    |     (poll every 100ms) |                    |\n  |                    |        ...timeout...   |                    |\n  |                    |                        |                    |\n  |                    |--interrupt()---------->|                    |\n  |                    |<--ok-------------------|                    |\n  |                    |                        |                    |\n  |                    |--abort()-------------->|                    |\n  |                    |                        |--exit/persist----->|\n  |                    |                        |                    |\n  |                    |--poll for file------------------------>|   |\n  |                    |     (every 100ms)                      |   |\n  |                    |<--file exists--------------------------|   |\n  |                    |                        |                    |\n  |                    |--create new Query----->| (resume)           |\n  |                    |   (restart original)   |                    |\n  |                    |                        |                    |\n  |                    |--create new Query----->| (resume+fork)      |\n  |                    |   (forked session)     |                    |\n  |                    |                        |                    |\n  |<--forked session---|                        |                    |\n```\n\n## Configuration\n\nDefault timeouts (can be overridden via `_meta`):\n\n```typescript\nconst DEFAULT_FLUSH_TIMEOUT = 5000;      // 5 seconds to wait for idle\nconst DEFAULT_PERSISTENCE_TIMEOUT = 5000; // 5 seconds to wait for disk\nconst POLL_INTERVAL = 100;               // 100ms between polls\nconst INTERRUPT_SETTLE_TIME = 100;       // 100ms after interrupt before abort\n```\n\n## Migration Notes\n\nThis change is **backward compatible**:\n- Existing fork calls continue to work\n- Sessions created before this change use direct fork (may still fail if not persisted)\n- New sessions automatically get fork-with-flush capability\n\n## Open Questions\n\n1. **Should we expose flush timeout in ACP protocol?**\n   - Currently via `_meta.flushTimeout`\n   - Could add to `ForkSessionRequest` schema\n\n2. **What if restart fails?**\n   - Session is flushed but not restarted\n   - Could leave in inconsistent state\n   - Consider: automatic retry? Leave flushed?\n\n3. **Concurrent fork requests?**\n   - What if two forks requested simultaneously?\n   - Current: Both would try to flush\n   - Consider: Queue/lock mechanism","priority":1,"archived":0,"archived_at":null,"created_at":"2025-12-17 23:50:41","updated_at":"2025-12-17 23:50:41","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["acp","claude-code-acp","forking","persistence","session-management"]}
{"id":"s-9pmn","uuid":"c7a6bbec-7f62-4e12-9b6c-92a3afe107c1","title":"Python Port of acp-factory","file_path":"specs/s-9pmn_python_port_of_acp_factory.md","content":"# Python Port of acp-factory\n\n## Overview\n\nPort the TypeScript `acp-factory` library to Python, creating a 1:1 API-compatible implementation for PyPI. The library provides a unified interface for spawning and managing AI agents through the Agent Client Protocol (ACP).\n\n## Dependencies\n\n- `agent-client-protocol>=0.7.0` - Python ACP SDK (provides `Client`, `ClientSideConnection`, `spawn_agent_process`, etc.)\n\n## Architecture\n\nThe Python implementation mirrors the TypeScript structure:\n\n```\nsrc/acp_factory/\n├── __init__.py          # Public exports\n├── types.py             # Type definitions (dataclasses)\n├── pushable.py          # Pushable async iterable (NEW)\n├── client_handler.py    # ACPClientHandler (NEW)\n├── agent_handle.py      # AgentHandle class\n├── session.py           # Session class\n├── factory.py           # AgentFactory class\n└── providers/           # Agent configurations\n    ├── claude_code.py\n    ├── codex.py\n    ├── gemini.py\n    └── opencode.py\n```\n\n---\n\n## Phase 1: Core Infrastructure\n\n### 1.1 Pushable Async Iterable\n\nPort the `Pushable<T>` class that bridges push-based and async-iterator-based code.\n\n**TypeScript reference:** `src/client-handler.ts:18-65`\n\n**Python implementation:**\n```python\nclass Pushable(AsyncIterable[T]):\n    \"\"\"Push-based async iterable for streaming session updates.\"\"\"\n    \n    def __init__(self) -> None:\n        self._queue: list[T] = []\n        self._waiters: list[asyncio.Future[T]] = []\n        self._done: bool = False\n    \n    def push(self, item: T) -> None: ...\n    def end(self) -> None: ...\n    def is_done(self) -> bool: ...\n    def __aiter__(self) -> AsyncIterator[T]: ...\n    async def __anext__(self) -> T: ...\n```\n\n**Acceptance Criteria:**\n- [ ] Items pushed before iteration are yielded in order\n- [ ] Awaiting on empty queue blocks until item pushed\n- [ ] `end()` signals completion to all waiters\n- [ ] Pushes after `end()` are ignored\n- [ ] `is_done()` reflects state correctly\n- [ ] Unit tests match TypeScript test cases\n\n### 1.2 Types Module Enhancement\n\nEnhance `types.py` with missing types needed by client handler.\n\n**Additions:**\n- Ensure all callback type signatures match TypeScript\n- Add any missing re-exports from `acp` library\n\n**Acceptance Criteria:**\n- [ ] All types from TypeScript `types.ts` have Python equivalents\n- [ ] Type annotations pass mypy strict mode\n\n---\n\n## Phase 2: Client Handler\n\n### 2.1 ACPClientHandler Implementation\n\nPort the `ACPClientHandler` class that implements the ACP `Client` protocol.\n\n**TypeScript reference:** `src/client-handler.ts:79-397`\n\n**Python implementation:**\n```python\nclass ACPClientHandler:\n    \"\"\"Implements ACP Client interface, bridging agent requests to callbacks.\"\"\"\n    \n    def __init__(\n        self,\n        handlers: ClientHandlers | None = None,\n        permission_mode: PermissionMode = \"auto-approve\",\n    ) -> None: ...\n    \n    # Stream management\n    def get_session_stream(self, session_id: str) -> Pushable[ExtendedSessionUpdate]: ...\n    def end_session_stream(self, session_id: str) -> None: ...\n    \n    # Permission handling (interactive mode)\n    def respond_to_permission(self, request_id: str, option_id: str) -> None: ...\n    def cancel_permission(self, request_id: str) -> None: ...\n    def has_pending_permissions(self) -> bool: ...\n    def get_pending_permission_ids(self, session_id: str) -> list[str]: ...\n    \n    # ACP Client protocol methods\n    async def request_permission(self, params: RequestPermissionRequest) -> RequestPermissionResponse: ...\n    async def session_update(self, params: SessionNotification) -> None: ...\n    async def read_text_file(self, params: ReadTextFileRequest) -> ReadTextFileResponse: ...\n    async def write_text_file(self, params: WriteTextFileRequest) -> WriteTextFileResponse: ...\n    async def create_terminal(self, params: CreateTerminalRequest) -> CreateTerminalResponse: ...\n    async def terminal_output(self, params: TerminalOutputRequest) -> TerminalOutputResponse: ...\n    async def kill_terminal(self, params: KillTerminalCommandRequest) -> KillTerminalCommandResponse: ...\n    async def release_terminal(self, params: ReleaseTerminalRequest) -> ReleaseTerminalResponse: ...\n    async def wait_for_terminal_exit(self, params: WaitForTerminalExitRequest) -> WaitForTerminalExitResponse: ...\n```\n\n**Permission Mode Logic:**\n- `auto-approve`: Select `allow_once` or `allow_always` option\n- `auto-deny`: Select `reject_once` or `reject_always` option\n- `callback`: Delegate to `handlers.on_permission_request`\n- `interactive`: Emit to session stream, await response via deferred promise\n\n**Acceptance Criteria:**\n- [ ] All 4 permission modes work correctly\n- [ ] Session streams are per-session isolated\n- [ ] Interactive mode emits `PermissionRequestUpdate` to stream\n- [ ] `respond_to_permission` / `cancel_permission` resolve pending requests\n- [ ] File read/write delegates to handlers or uses filesystem\n- [ ] Terminal operations delegate to handlers or raise errors\n- [ ] Unit tests match TypeScript test cases (45+ tests)\n\n---\n\n## Phase 3: Agent Handle\n\n### 3.1 AgentHandle Implementation\n\nPort the `AgentHandle` class that manages agent subprocess and ACP connection.\n\n**TypeScript reference:** `src/agent-handle.ts`\n\n**Python implementation:**\n```python\nclass AgentHandle:\n    \"\"\"Handle to a running agent process with ACP connection.\"\"\"\n    \n    def __init__(\n        self,\n        process: asyncio.subprocess.Process,\n        connection: ClientSideConnection,\n        client_handler: ACPClientHandler,\n        capabilities: dict[str, Any],\n    ) -> None: ...\n    \n    @classmethod\n    async def create(\n        cls,\n        config: AgentConfig,\n        options: SpawnOptions,\n    ) -> AgentHandle: ...\n    \n    async def create_session(self, cwd: str, options: SessionOptions | None = None) -> Session: ...\n    async def load_session(self, session_id: str, cwd: str, mcp_servers: list[dict] | None = None) -> Session: ...\n    async def fork_session(self, session_id: str, cwd: str, options: ForkSessionOptions | None = None) -> Session: ...\n    async def close(self) -> None: ...\n    def get_connection(self) -> ClientSideConnection: ...\n    def is_running(self) -> bool: ...\n```\n\n**Key implementation details:**\n- Use `acp.spawn_agent_process()` or `asyncio.create_subprocess_exec()` + `acp.connect_to_agent()`\n- Initialize connection with `connection.initialize()`\n- Track sessions in `_sessions` dict for smart fork detection\n\n**Acceptance Criteria:**\n- [ ] Spawns subprocess with correct command/args/env\n- [ ] Establishes ACP connection over NDJSON streams\n- [ ] `capabilities` populated from initialization response\n- [ ] `create_session` returns working Session\n- [ ] `load_session` works when capability present\n- [ ] `fork_session` uses smart detection (flush if processing)\n- [ ] `close()` terminates process and awaits cleanup\n- [ ] `is_running()` reflects process state\n\n---\n\n## Phase 4: Session\n\n### 4.1 Session Implementation\n\nPort the `Session` class for high-level agent interaction.\n\n**TypeScript reference:** `src/session.ts`\n\n**Python implementation:**\n```python\nclass Session:\n    \"\"\"Represents an active session with an agent.\"\"\"\n    \n    def __init__(\n        self,\n        session_id: str,\n        connection: ClientSideConnection,\n        client_handler: ACPClientHandler,\n        cwd: str,\n        modes: list[str] | None = None,\n        models: list[str] | None = None,\n    ) -> None: ...\n    \n    # Properties\n    @property\n    def id(self) -> str: ...\n    @property\n    def is_processing(self) -> bool: ...\n    \n    # Core methods\n    async def prompt(self, content: PromptContent) -> AsyncIterator[ExtendedSessionUpdate]: ...\n    async def cancel(self) -> None: ...\n    async def interrupt_with(self, content: PromptContent) -> AsyncIterator[ExtendedSessionUpdate]: ...\n    async def set_mode(self, mode: str) -> None: ...\n    \n    # Forking\n    async def fork(self) -> Session: ...\n    async def fork_with_flush(self, idle_timeout: int = 5000, persist_timeout: int = 5000) -> Session: ...\n    \n    # Permissions (interactive mode)\n    def respond_to_permission(self, request_id: str, option_id: str) -> None: ...\n    def cancel_permission(self, request_id: str) -> None: ...\n    def has_pending_permissions(self) -> bool: ...\n    def get_pending_permission_ids(self) -> list[str]: ...\n    \n    # Persistence\n    async def flush(self, options: FlushOptions | None = None) -> FlushResult: ...\n```\n\n**Key implementation details:**\n- `prompt()` is an async generator that races between prompt completion and stream updates\n- `is_processing` flag tracks active prompt state\n- `fork_with_flush()` handles active sessions by flushing to disk first\n\n**Acceptance Criteria:**\n- [ ] `prompt()` yields all session updates as async iterator\n- [ ] `prompt()` handles prompt completion and drains remaining updates\n- [ ] `cancel()` cancels current prompt\n- [ ] `interrupt_with()` cancels then starts new prompt\n- [ ] `set_mode()` changes session mode\n- [ ] `fork()` creates independent session copy\n- [ ] `fork_with_flush()` handles active sessions correctly\n- [ ] Permission methods delegate to client handler\n- [ ] `is_processing` correctly tracks state\n\n---\n\n## Phase 5: Factory & Integration\n\n### 5.1 AgentFactory Finalization\n\nComplete the `AgentFactory` class with full functionality.\n\n**Already implemented:** Basic structure, provider registration\n\n**Remaining:**\n- Ensure `spawn()` correctly creates `AgentHandle`\n- Verify environment variable merging\n\n**Acceptance Criteria:**\n- [ ] All 4 providers registered on import\n- [ ] `spawn()` returns working `AgentHandle`\n- [ ] Environment variables merge correctly (options override config)\n- [ ] Unknown agent type raises descriptive error\n- [ ] Unit tests match TypeScript test cases\n\n### 5.2 Public API Exports\n\nEnsure `__init__.py` exports match TypeScript exports.\n\n**Acceptance Criteria:**\n- [ ] All public classes exported: `AgentFactory`, `AgentHandle`, `Session`, `Pushable`\n- [ ] All public types exported\n- [ ] Re-exports from `acp` library as needed\n\n---\n\n## Phase 6: Testing\n\n### 6.1 Unit Tests\n\nPort all unit tests from TypeScript to Python pytest.\n\n**Test files to create:**\n- `tests/test_pushable.py` - Pushable async iterable tests\n- `tests/test_client_handler.py` - ACPClientHandler tests (45+ tests)\n- `tests/test_factory.py` - AgentFactory tests\n- `tests/test_session.py` - Session tests\n- `tests/test_agent_handle.py` - AgentHandle tests\n\n**Acceptance Criteria:**\n- [ ] All TypeScript unit tests ported\n- [ ] Tests pass with `pytest`\n- [ ] Coverage >80%\n\n### 6.2 E2E Tests (Optional)\n\nPort E2E tests if agents are available in test environment.\n\n**Test files:**\n- `tests/e2e/test_codex.py`\n- `tests/e2e/test_gemini.py`\n- `tests/e2e/test_opencode.py`\n\n**Acceptance Criteria:**\n- [ ] E2E tests work when agents installed\n- [ ] Tests skipped gracefully when agents unavailable\n\n---\n\n## Phase 7: Documentation & Release\n\n### 7.1 Documentation\n\n- [ ] Update README with accurate Python examples\n- [ ] Ensure docstrings on all public methods\n- [ ] Add inline code examples\n\n### 7.2 Release\n\n- [ ] Version bump to 0.1.0\n- [ ] Update CHANGELOG\n- [ ] Publish to PyPI\n\n---\n\n## API Compatibility Matrix\n\n| TypeScript | Python | Status |\n|------------|--------|--------|\n| `AgentFactory.spawn()` | `AgentFactory.spawn()` | Skeleton |\n| `AgentFactory.register()` | `AgentFactory.register()` | Done |\n| `AgentFactory.listAgents()` | `AgentFactory.list_agents()` | Done |\n| `AgentHandle.createSession()` | `AgentHandle.create_session()` | Stub |\n| `AgentHandle.loadSession()` | `AgentHandle.load_session()` | Stub |\n| `AgentHandle.forkSession()` | `AgentHandle.fork_session()` | Stub |\n| `AgentHandle.close()` | `AgentHandle.close()` | Stub |\n| `Session.prompt()` | `Session.prompt()` | Stub |\n| `Session.cancel()` | `Session.cancel()` | Stub |\n| `Session.interruptWith()` | `Session.interrupt_with()` | Stub |\n| `Session.fork()` | `Session.fork()` | Stub |\n| `Session.forkWithFlush()` | `Session.fork_with_flush()` | Stub |\n| `Session.flush()` | `Session.flush()` | Stub |\n| `Pushable` | `Pushable` | Not started |\n| `ACPClientHandler` | `ACPClientHandler` | Not started |\n\n---\n\n## Success Criteria\n\n1. **API Parity:** All TypeScript public APIs have Python equivalents\n2. **Behavior Parity:** Same behavior for same inputs\n3. **Test Parity:** All unit tests ported and passing\n4. **Type Safety:** Passes mypy strict mode\n5. **Publishable:** Successfully published to PyPI as `acp-factory`\n","priority":1,"archived":0,"archived_at":null,"created_at":"2026-01-06 23:50:13","updated_at":"2026-01-06 23:50:13","parent_id":null,"parent_uuid":null,"relationships":[],"tags":["acp","port","python","sdk"]}
